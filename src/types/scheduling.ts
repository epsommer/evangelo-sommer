// src/types/scheduling.ts

export type FrequencyType = "daily" | "weekly" | "bi-weekly" | "monthly" | "custom";

export type EndRuleType = "never" | "occurrences" | "date";

export interface ScheduleRule {
  id: string;
  frequency: FrequencyType;
  interval: number; // every X days/weeks/months
  daysOfWeek?: number[]; // for weekly (0=Sunday, 6=Saturday)
  dayOfMonth?: number; // for monthly (1-31, -1=last day)
  endRule: {
    type: EndRuleType;
    value?: number | string; // number for occurrences, ISO string for date
  };
  timezone?: string;
  createdAt: string;
  updatedAt: string;
}

export interface RecurringEvent {
  id: string;
  scheduleRuleId: string;
  title: string;
  description?: string;
  clientId: string;
  conversationId?: string;
  nextOccurrence: string; // ISO date string
  lastOccurrence?: string; // ISO date string
  totalOccurrences: number;
  isActive: boolean;
  metadata?: {
    reminderMinutesBefore?: number;
    autoCreateTask?: boolean;
    notificationPreferences?: {
      email?: boolean;
      sms?: boolean;
      push?: boolean;
    };
  };
  createdAt: string;
  updatedAt: string;
}

export interface CalendarEvent {
  id: string;
  title: string;
  description?: string;
  startTime: string; // ISO date-time string
  endTime: string; // ISO date-time string
  clientId: string;
  conversationId?: string;
  recurringEventId?: string;
  type: "follow-up" | "appointment" | "deadline" | "reminder";
  status: "scheduled" | "completed" | "cancelled" | "rescheduled";
  attendees?: string[];
  location?: string;
  isAllDay: boolean;
  metadata?: {
    meetingLink?: string;
    reminderSent?: boolean;
    confirmationRequired?: boolean;
    autoGenerated?: boolean;
    integrationId?: string;
  };
  createdAt: string;
  updatedAt: string;
}

export interface FrequencyOption {
  label: string;
  value: FrequencyType;
  description: string;
  intervalRange: { min: number; max: number };
  defaultInterval: number;
}

export interface ScheduleConflict {
  id: string;
  eventId: string;
  conflictingEventId: string;
  type: "overlap" | "double-booking" | "resource-conflict";
  severity: "low" | "medium" | "high";
  suggestedResolution?: {
    action: "reschedule" | "merge" | "split";
    newDateTime?: string;
    reason: string;
  };
}

export interface CalendarIntegration {
  id: string;
  provider: "google" | "outlook" | "apple" | "custom";
  accountId: string;
  calendarId: string;
  isActive: boolean;
  syncEnabled: boolean;
  lastSyncAt?: string;
  syncSettings: {
    syncDirection: "bidirectional" | "to-external" | "from-external";
    autoCreateEvents: boolean;
    eventPrefix?: string;
    defaultVisibility: "public" | "private" | "confidential";
  };
  credentials?: {
    accessToken?: string;
    refreshToken?: string;
    expiresAt?: string;
  };
  createdAt: string;
  updatedAt: string;
}

// Utility types for frequency calculations
export interface FrequencyCalculationOptions {
  startDate: string;
  scheduleRule: ScheduleRule;
  occurrenceLimit?: number;
  endDate?: string;
}

export interface CalculatedOccurrence {
  date: string;
  isLast: boolean;
  occurrenceNumber: number;
  metadata?: {
    isHoliday?: boolean;
    isWeekend?: boolean;
    adjustedFromOriginal?: boolean;
    originalDate?: string;
  };
}

export interface FrequencyValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  suggestedFixes?: Partial<ScheduleRule>[];
}

// Calendar view types
export type CalendarView = "day" | "week" | "month" | "year" | "agenda";

export interface CalendarViewSettings {
  view: CalendarView;
  startDate: string;
  timezone: string;
  workingHours: {
    start: string; // HH:MM format
    end: string; // HH:MM format
    workingDays: number[]; // 0=Sunday, 6=Saturday
  };
  displaySettings: {
    showWeekends: boolean;
    showDeclinedEvents: boolean;
    showAllDayEvents: boolean;
    defaultEventDuration: number; // minutes
  };
}

// Follow-up scheduling types
export interface FollowUpRule {
  id: string;
  name: string;
  description?: string;
  trigger: {
    type:
      | "conversation-status"
      | "message-sent"
      | "deadline-approaching"
      | "custom";
    conditions: Record<string, unknown>;
  };
  action: {
    type: "create-event" | "send-reminder" | "create-task";
    delay: number; // minutes after trigger
    template: {
      title: string;
      description?: string;
      duration?: number; // minutes
    };
  };
  isActive: boolean;
  clientIds?: string[]; // if empty, applies to all clients
  serviceIds?: string[]; // if empty, applies to all services
  createdAt: string;
  updatedAt: string;
}

export interface ScheduledFollowUp {
  id: string;
  followUpRuleId: string;
  clientId: string;
  conversationId: string;
  scheduledFor: string;
  status: "pending" | "completed" | "cancelled" | "failed";
  attemptCount: number;
  lastAttemptAt?: string;
  completedAt?: string;
  metadata?: {
    originalTrigger: string;
    errorMessage?: string;
    manuallyTriggered?: boolean;
  };
  createdAt: string;
  updatedAt: string;
}

// Analytics types for scheduling
export interface SchedulingMetrics {
  totalEvents: number;
  upcomingEvents: number;
  completedEvents: number;
  cancelledEvents: number;
  averageEventDuration: number;
  mostActiveDay: number; // day of week
  mostActiveHour: number; // hour of day (0-23)
  followUpCompletionRate: number; // percentage
  averageResponseTime: number; // hours
  recurringEventAdherence: number; // percentage
}

export interface SchedulingInsight {
  type: "pattern" | "optimization" | "conflict" | "suggestion";
  title: string;
  description: string;
  actionable: boolean;
  priority: "low" | "medium" | "high";
  relatedData: {
    clientIds?: string[];
    eventIds?: string[];
    timeRange?: { start: string; end: string };
  };
  suggestedAction?: {
    title: string;
    description: string;
    actionType: "reschedule" | "automate" | "optimize" | "investigate";
  };
  createdAt: string;
}

// Export utility type for component props
export interface SchedulingContextType {
  events: CalendarEvent[];
  recurringEvents: RecurringEvent[];
  scheduleRules: ScheduleRule[];
  integrations: CalendarIntegration[];
  followUpRules: FollowUpRule[];
  scheduledFollowUps: ScheduledFollowUp[];
  isLoading: boolean;
  error: string | null;

  // Actions
  createEvent: (
    event: Omit<CalendarEvent, "id" | "createdAt" | "updatedAt">,
  ) => Promise<CalendarEvent>;
  updateEvent: (
    id: string,
    updates: Partial<CalendarEvent>,
  ) => Promise<CalendarEvent>;
  deleteEvent: (id: string) => Promise<void>;
  createScheduleRule: (
    rule: Omit<ScheduleRule, "id" | "createdAt" | "updatedAt">,
  ) => Promise<ScheduleRule>;
  calculateNextOccurrences: (
    ruleId: string,
    count: number,
  ) => Promise<CalculatedOccurrence[]>;
  validateFrequency: (rule: Partial<ScheduleRule>) => FrequencyValidationResult;
  detectConflicts: (eventId: string) => Promise<ScheduleConflict[]>;
  getSchedulingInsights: (clientId?: string) => Promise<SchedulingInsight[]>;
}
