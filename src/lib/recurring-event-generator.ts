import { CalendarEvent, RecurringEvent, ScheduleRule } from '@/types/scheduling'
import FrequencyCalculator from './frequency-calculator'

export interface EventGenerationOptions {
  lookAheadDays?: number
  maxEventsPerRecurrence?: number
  excludeWeekends?: boolean
  excludeHolidays?: boolean
  defaultDuration?: number // minutes
}

export interface GeneratedEventsBatch {
  events: CalendarEvent[]
  recurringEventId: string
  nextScheduledGeneration: string | null
  generatedUntil: string
}

export class RecurringEventGenerator {
  private static readonly DEFAULT_OPTIONS: EventGenerationOptions = {
    lookAheadDays: 90,
    maxEventsPerRecurrence: 50,
    excludeWeekends: false,
    excludeHolidays: false,
    defaultDuration: 60
  }

  /**
   * Generate calendar events from a recurring event
   */
  static generateEventsFromRecurring(
    recurringEvent: RecurringEvent,
    scheduleRule: ScheduleRule,
    options: EventGenerationOptions = {}
  ): GeneratedEventsBatch {
    const opts = { ...this.DEFAULT_OPTIONS, ...options }
    
    // Calculate the date range for generation
    const startDate = recurringEvent.nextOccurrence || new Date().toISOString()
    const endDate = new Date()
    endDate.setDate(endDate.getDate() + opts.lookAheadDays!)
    
    // Calculate occurrences
    const occurrences = FrequencyCalculator.calculateNextOccurrences({
      startDate,
      scheduleRule,
      occurrenceLimit: opts.maxEventsPerRecurrence!,
      endDate: endDate.toISOString()
    })

    // Filter occurrences if needed
    const filteredOccurrences = occurrences.filter(occurrence => {
      const occurrenceDate = new Date(occurrence.date)
      
      if (opts.excludeWeekends && this.isWeekend(occurrenceDate)) {
        return false
      }
      
      if (opts.excludeHolidays && occurrence.metadata?.isHoliday) {
        return false
      }
      
      return true
    })

    // Generate calendar events
    const events: CalendarEvent[] = filteredOccurrences.map((occurrence, index) => {
      const startTime = new Date(occurrence.date)
      const endTime = new Date(startTime)
      endTime.setMinutes(endTime.getMinutes() + opts.defaultDuration!)

      return {
        id: `recurring_${recurringEvent.id}_${index}_${startTime.getTime()}`,
        title: recurringEvent.title,
        description: recurringEvent.description,
        startTime: startTime.toISOString(),
        endTime: endTime.toISOString(),
        clientId: recurringEvent.clientId,
        conversationId: recurringEvent.conversationId,
        recurringEventId: recurringEvent.id,
        type: 'appointment', // Default type for recurring events
        status: 'scheduled',
        attendees: [],
        location: undefined,
        isAllDay: false,
        metadata: {
          autoGenerated: true,
          occurrenceNumber: occurrence.occurrenceNumber,
          isLastOccurrence: occurrence.isLast,
          reminderSent: false,
          confirmationRequired: false,
          recurringEventTitle: recurringEvent.title,
          scheduleRuleId: scheduleRule.id
        },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
    })

    // Determine next generation date
    const lastOccurrence = filteredOccurrences[filteredOccurrences.length - 1]
    const nextScheduledGeneration = lastOccurrence && !lastOccurrence.isLast
      ? FrequencyCalculator.getNextOccurrenceDate(lastOccurrence.date, scheduleRule)
      : null

    return {
      events,
      recurringEventId: recurringEvent.id,
      nextScheduledGeneration,
      generatedUntil: lastOccurrence ? lastOccurrence.date : startDate
    }
  }

  /**
   * Update a recurring event's next occurrence based on generated events
   */
  static updateRecurringEventProgress(
    recurringEvent: RecurringEvent,
    generatedBatch: GeneratedEventsBatch
  ): RecurringEvent {
    return {
      ...recurringEvent,
      nextOccurrence: generatedBatch.nextScheduledGeneration || recurringEvent.nextOccurrence,
      lastOccurrence: generatedBatch.events.length > 0 
        ? generatedBatch.events[generatedBatch.events.length - 1].startTime
        : recurringEvent.lastOccurrence,
      totalOccurrences: recurringEvent.totalOccurrences + generatedBatch.events.length,
      updatedAt: new Date().toISOString()
    }
  }

  /**
   * Generate events for multiple recurring events
   */
  static generateEventsForMultipleRecurring(
    recurringEvents: { recurringEvent: RecurringEvent; scheduleRule: ScheduleRule }[],
    options: EventGenerationOptions = {}
  ): {
    allEvents: CalendarEvent[]
    batches: GeneratedEventsBatch[]
    updatedRecurringEvents: RecurringEvent[]
  } {
    const allEvents: CalendarEvent[] = []
    const batches: GeneratedEventsBatch[] = []
    const updatedRecurringEvents: RecurringEvent[] = []

    for (const { recurringEvent, scheduleRule } of recurringEvents) {
      if (!recurringEvent.isActive) continue

      const batch = this.generateEventsFromRecurring(recurringEvent, scheduleRule, options)
      const updatedRecurring = this.updateRecurringEventProgress(recurringEvent, batch)

      allEvents.push(...batch.events)
      batches.push(batch)
      updatedRecurringEvents.push(updatedRecurring)
    }

    // Sort events by start time
    allEvents.sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime())

    return {
      allEvents,
      batches,
      updatedRecurringEvents
    }
  }

  /**
   * Check if new events need to be generated for a recurring event
   */
  static needsEventGeneration(
    recurringEvent: RecurringEvent,
    existingEvents: CalendarEvent[],
    lookAheadDays: number = 30
  ): boolean {
    if (!recurringEvent.isActive || !recurringEvent.nextOccurrence) {
      return false
    }

    const nextOccurrenceDate = new Date(recurringEvent.nextOccurrence)
    const lookAheadDate = new Date()
    lookAheadDate.setDate(lookAheadDate.getDate() + lookAheadDays)

    // Check if the next occurrence is within our look-ahead window
    if (nextOccurrenceDate <= lookAheadDate) {
      // Check if we already have events generated for this recurring event in the near future
      const recurringEvents = existingEvents.filter(
        event => event.recurringEventId === recurringEvent.id
      )

      const futureEvents = recurringEvents.filter(
        event => new Date(event.startTime) > new Date()
      )

      // If we have fewer than 3 future events, we should generate more
      return futureEvents.length < 3
    }

    return false
  }

  /**
   * Create a bi-weekly recurring event template
   */
  static createBiWeeklyRecurringEvent(
    title: string,
    clientId: string,
    daysOfWeek: number[] = [1], // Default to Monday
    startDate?: string,
    endAfterOccurrences?: number
  ): { recurringEvent: RecurringEvent; scheduleRule: ScheduleRule } {
    const now = new Date()
    const startDateTime = startDate ? new Date(startDate) : now
    
    // Set to next occurrence of the specified day
    if (daysOfWeek.length > 0) {
      const targetDay = daysOfWeek[0]
      const dayDiff = targetDay - startDateTime.getDay()
      if (dayDiff <= 0) {
        startDateTime.setDate(startDateTime.getDate() + (dayDiff + 7))
      } else {
        startDateTime.setDate(startDateTime.getDate() + dayDiff)
      }
    }

    const scheduleRule: ScheduleRule = {
      id: `schedule_${Date.now()}`,
      frequency: 'bi-weekly',
      interval: 1, // Every 1 bi-week (every 2 weeks)
      daysOfWeek,
      endRule: endAfterOccurrences 
        ? { type: 'occurrences', value: endAfterOccurrences }
        : { type: 'never' },
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      createdAt: now.toISOString(),
      updatedAt: now.toISOString()
    }

    const recurringEvent: RecurringEvent = {
      id: `recurring_${Date.now()}`,
      scheduleRuleId: scheduleRule.id,
      title,
      description: 'Automatically generated bi-weekly appointment',
      clientId,
      nextOccurrence: startDateTime.toISOString(),
      totalOccurrences: 0,
      isActive: true,
      metadata: {
        reminderMinutesBefore: 30,
        autoCreateTask: false,
        notificationPreferences: {
          email: true,
          push: true
        }
      },
      createdAt: now.toISOString(),
      updatedAt: now.toISOString()
    }

    return { recurringEvent, scheduleRule }
  }

  /**
   * Utility methods
   */
  private static isWeekend(date: Date): boolean {
    const day = date.getDay()
    return day === 0 || day === 6 // Sunday or Saturday
  }

  /**
   * Get human-readable description of when events will be generated
   */
  static getGenerationSummary(
    recurringEvent: RecurringEvent,
    scheduleRule: ScheduleRule,
    options: EventGenerationOptions = {}
  ): {
    nextEventDate: string | null
    totalEventsToGenerate: number
    generationPeriod: string
    description: string
  } {
    const opts = { ...this.DEFAULT_OPTIONS, ...options }
    
    const batch = this.generateEventsFromRecurring(recurringEvent, scheduleRule, opts)
    
    const nextEventDate = batch.events.length > 0 ? batch.events[0].startTime : null
    const totalEventsToGenerate = batch.events.length
    const generationPeriod = `${opts.lookAheadDays} days`
    
    let description = FrequencyCalculator.describeScheduleRule(scheduleRule)
    if (totalEventsToGenerate > 0) {
      description += ` - ${totalEventsToGenerate} events will be created over the next ${opts.lookAheadDays} days`
    } else {
      description += ` - No events to create in the next ${opts.lookAheadDays} days`
    }

    return {
      nextEventDate,
      totalEventsToGenerate,
      generationPeriod,
      description
    }
  }
}

export default RecurringEventGenerator