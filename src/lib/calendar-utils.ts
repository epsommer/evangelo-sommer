// src/lib/calendar-utils.ts

import {
  CalendarEvent,
  ScheduleConflict,
  SchedulingMetrics,
  SchedulingInsight,
} from "../types/scheduling";
import { Conversation } from "../types/client";

export class CalendarUtils {
  /**
   * Generate calendar events from conversation follow-ups
   */
  static generateEventsFromConversation(
    conversation: Conversation,
  ): CalendarEvent[] {
    const events: CalendarEvent[] = [];

    if (!conversation.nextActions || conversation.nextActions.length === 0) {
      return events;
    }

    conversation.nextActions.forEach((action, index) => {
      const event = this.createEventFromAction(conversation, action, index);
      if (event) {
        events.push(event);
      }
    });

    return events;
  }

  /**
   * Create a calendar event from a conversation action item
   */
  private static createEventFromAction(
    conversation: Conversation,
    action: string,
    index: number,
  ): CalendarEvent | null {
    // Extract timing information from action text
    const timingInfo = this.extractTimingFromText(action);

    if (!timingInfo.hasDeadline && !timingInfo.isUrgent) {
      // Default to 3 days from now for non-urgent items
      timingInfo.suggestedDate = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000);
    }

    const startTime =
      timingInfo.suggestedDate || new Date(Date.now() + 24 * 60 * 60 * 1000);
    const endTime = new Date(startTime.getTime() + 60 * 60 * 1000); // 1 hour duration

    return {
      id: `event_${conversation.id}_${index}_${Date.now()}`,
      title: this.generateEventTitle(action),
      description: this.generateEventDescription(action, conversation),
      startTime: startTime.toISOString(),
      endTime: endTime.toISOString(),
      clientId: conversation.clientId,
      conversationId: conversation.id,
      type: this.determineEventType(action),
      status: "scheduled",
      isAllDay: timingInfo.isAllDay || false,
      metadata: {
        autoGenerated: true,
        reminderSent: false,
        confirmationRequired: timingInfo.needsConfirmation || false,
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
  }

  /**
   * Extract timing information from action text
   */
  private static extractTimingFromText(text: string): {
    hasDeadline: boolean;
    isUrgent: boolean;
    isAllDay: boolean;
    needsConfirmation: boolean;
    suggestedDate: Date | null;
  } {
    const lowerText = text.toLowerCase();

    // Check for urgency indicators
    const urgentKeywords = [
      "urgent",
      "asap",
      "immediately",
      "emergency",
      "critical",
    ];
    const isUrgent = urgentKeywords.some((keyword) =>
      lowerText.includes(keyword),
    );

    // Check for deadline indicators
    const deadlinePatterns = [
      /by (\w+day)/i, // by Monday, Tuesday, etc.
      /by (\w+ \d+)/i, // by March 15
      /within (\d+) (days?|hours?|weeks?)/i,
      /in (\d+) (days?|hours?|weeks?)/i,
      /before (\w+day)/i,
      /until (\w+ \d+)/i,
    ];

    let hasDeadline = false;
    let suggestedDate: Date | null = null;

    for (const pattern of deadlinePatterns) {
      const match = text.match(pattern);
      if (match) {
        hasDeadline = true;
        suggestedDate = this.parseRelativeDate(match[0]);
        break;
      }
    }

    // Check for confirmation requirements
    const confirmationKeywords = [
      "schedule",
      "arrange",
      "confirm",
      "book",
      "appointment",
    ];
    const needsConfirmation = confirmationKeywords.some((keyword) =>
      lowerText.includes(keyword),
    );

    // Check for all-day events
    const allDayKeywords = ["deadline", "due date", "submit by", "complete by"];
    const isAllDay = allDayKeywords.some((keyword) =>
      lowerText.includes(keyword),
    );

    // If urgent but no specific date, suggest within 24 hours
    if (isUrgent && !suggestedDate) {
      suggestedDate = new Date(Date.now() + 24 * 60 * 60 * 1000);
    }

    return {
      hasDeadline,
      isUrgent,
      isAllDay,
      needsConfirmation,
      suggestedDate,
    };
  }

  /**
   * Parse relative date from text
   */
  private static parseRelativeDate(dateText: string): Date {
    const now = new Date();
    const lowerText = dateText.toLowerCase();

    // Handle "in X days/hours/weeks"
    const relativeMatch = lowerText.match(/in (\d+) (days?|hours?|weeks?)/);
    if (relativeMatch) {
      const amount = parseInt(relativeMatch[1]);
      const unit = relativeMatch[2];

      if (unit.startsWith("day")) {
        return new Date(now.getTime() + amount * 24 * 60 * 60 * 1000);
      } else if (unit.startsWith("hour")) {
        return new Date(now.getTime() + amount * 60 * 60 * 1000);
      } else if (unit.startsWith("week")) {
        return new Date(now.getTime() + amount * 7 * 24 * 60 * 60 * 1000);
      }
    }

    // Handle day names
    const dayNames = [
      "sunday",
      "monday",
      "tuesday",
      "wednesday",
      "thursday",
      "friday",
      "saturday",
    ];
    const dayMatch = dayNames.find((day) => lowerText.includes(day));
    if (dayMatch) {
      const targetDay = dayNames.indexOf(dayMatch);
      const currentDay = now.getDay();
      let daysToAdd = targetDay - currentDay;

      if (daysToAdd <= 0) {
        daysToAdd += 7; // Next week
      }

      return new Date(now.getTime() + daysToAdd * 24 * 60 * 60 * 1000);
    }

    // Default: tomorrow
    return new Date(now.getTime() + 24 * 60 * 60 * 1000);
  }

  /**
   * Generate event title from action text
   */
  private static generateEventTitle(action: string): string {
    // Extract the main action from the text
    const cleanAction = action
      .replace(/^(please|can you|need to|should|must)\s+/i, "")
      .replace(/\s+by\s+\w+day.*$/i, "")
      .replace(/\s+in\s+\d+\s+(days?|hours?|weeks?).*$/i, "")
      .trim();

    // Capitalize first letter
    const title = cleanAction.charAt(0).toUpperCase() + cleanAction.slice(1);

    return title.length > 50 ? title.substring(0, 47) + "..." : title;
  }

  /**
   * Generate event description
   */
  private static generateEventDescription(
    action: string,
    conversation: Conversation,
  ): string {
    const lines = [
      `Follow-up action from conversation: ${conversation.title || "Untitled"}`,
      "",
      `Action: ${action}`,
      "",
      `Client: [Client Name]`, // Would be filled from actual client data
      `Priority: ${conversation.priority || "medium"}`,
      `Source: ${conversation.source || "unknown"}`,
    ];

    if (conversation.summary) {
      lines.push("", `Context: ${conversation.summary}`);
    }

    return lines.join("\n");
  }

  /**
   * Determine event type from action text
   */
  private static determineEventType(action: string): CalendarEvent["type"] {
    const lowerAction = action.toLowerCase();

    if (lowerAction.includes("follow up") || lowerAction.includes("check in")) {
      return "follow-up";
    }

    if (
      lowerAction.includes("meeting") ||
      lowerAction.includes("appointment") ||
      lowerAction.includes("visit") ||
      lowerAction.includes("call")
    ) {
      return "appointment";
    }

    if (
      lowerAction.includes("deadline") ||
      lowerAction.includes("due") ||
      lowerAction.includes("submit") ||
      lowerAction.includes("complete")
    ) {
      return "deadline";
    }

    return "reminder";
  }

  /**
   * Detect scheduling conflicts between events
   */
  static detectConflicts(events: CalendarEvent[]): ScheduleConflict[] {
    const conflicts: ScheduleConflict[] = [];

    for (let i = 0; i < events.length; i++) {
      for (let j = i + 1; j < events.length; j++) {
        const event1 = events[i];
        const event2 = events[j];

        const conflict = this.checkEventConflict(event1, event2);
        if (conflict) {
          conflicts.push(conflict);
        }
      }
    }

    return conflicts;
  }

  /**
   * Check if two events conflict
   */
  private static checkEventConflict(
    event1: CalendarEvent,
    event2: CalendarEvent,
  ): ScheduleConflict | null {
    const start1 = new Date(event1.startTime);
    const end1 = new Date(event1.endTime);
    const start2 = new Date(event2.startTime);
    const end2 = new Date(event2.endTime);

    // Check for time overlap
    const hasOverlap = start1 < end2 && start2 < end1;

    if (!hasOverlap) {
      return null;
    }

    // Determine conflict type and severity
    let conflictType: ScheduleConflict["type"] = "overlap";
    let severity: ScheduleConflict["severity"] = "medium";

    // Same client at same time = double booking
    if (event1.clientId === event2.clientId) {
      conflictType = "double-booking";
      severity = "high";
    }

    // Complete time overlap = resource conflict
    if (
      start1.getTime() === start2.getTime() &&
      end1.getTime() === end2.getTime()
    ) {
      conflictType = "resource-conflict";
      severity = "high";
    }

    return {
      id: `conflict_${event1.id}_${event2.id}`,
      eventId: event1.id,
      conflictingEventId: event2.id,
      type: conflictType,
      severity,
      suggestedResolution: this.generateResolutionSuggestion(
        event1,
        event2,
        conflictType,
      ),
    };
  }

  /**
   * Generate conflict resolution suggestion
   */
  private static generateResolutionSuggestion(
    event1: CalendarEvent,
    event2: CalendarEvent,
    conflictType: ScheduleConflict["type"],
  ): ScheduleConflict["suggestedResolution"] {
    if (conflictType === "double-booking") {
      return {
        action: "reschedule",
        newDateTime: new Date(
          new Date(event2.startTime).getTime() + 60 * 60 * 1000,
        ).toISOString(),
        reason: "Move second event 1 hour later to avoid double-booking",
      };
    }

    if (conflictType === "resource-conflict") {
      return {
        action: "merge",
        reason:
          "Consider combining these events if they involve the same client/topic",
      };
    }

    return {
      action: "reschedule",
      newDateTime: new Date(
        new Date(event1.endTime).getTime() + 15 * 60 * 1000,
      ).toISOString(),
      reason: "Schedule after the first event with 15-minute buffer",
    };
  }

  /**
   * Calculate scheduling metrics
   */
  static calculateSchedulingMetrics(
    events: CalendarEvent[],
  ): SchedulingMetrics {
    const now = new Date();
    const upcomingEvents = events.filter((e) => new Date(e.startTime) > now);
    const completedEvents = events.filter((e) => e.status === "completed");
    const cancelledEvents = events.filter((e) => e.status === "cancelled");

    // Calculate average duration
    const durations = events.map(
      (e) => new Date(e.endTime).getTime() - new Date(e.startTime).getTime(),
    );
    const averageDuration =
      durations.length > 0
        ? durations.reduce((sum, duration) => sum + duration, 0) /
          durations.length /
          (1000 * 60)
        : 0;

    // Find most active day and hour
    const dayCount: Record<number, number> = {};
    const hourCount: Record<number, number> = {};

    events.forEach((event) => {
      const date = new Date(event.startTime);
      const day = date.getDay();
      const hour = date.getHours();

      dayCount[day] = (dayCount[day] || 0) + 1;
      hourCount[hour] = (hourCount[hour] || 0) + 1;
    });

    const mostActiveDay = Object.entries(dayCount).sort(
      ([, a], [, b]) => b - a,
    )[0]?.[0]
      ? parseInt(Object.entries(dayCount).sort(([, a], [, b]) => b - a)[0][0])
      : 1;

    const mostActiveHour = Object.entries(hourCount).sort(
      ([, a], [, b]) => b - a,
    )[0]?.[0]
      ? parseInt(Object.entries(hourCount).sort(([, a], [, b]) => b - a)[0][0])
      : 9;

    return {
      totalEvents: events.length,
      upcomingEvents: upcomingEvents.length,
      completedEvents: completedEvents.length,
      cancelledEvents: cancelledEvents.length,
      averageEventDuration: averageDuration,
      mostActiveDay,
      mostActiveHour,
      followUpCompletionRate:
        events.length > 0 ? (completedEvents.length / events.length) * 100 : 0,
      averageResponseTime: 24, // Placeholder - would need actual response time data
      recurringEventAdherence: 85, // Placeholder - would need recurring event data
    };
  }

  /**
   * Generate scheduling insights
   */
  static generateSchedulingInsights(
    events: CalendarEvent[],
  ): SchedulingInsight[] {
    const insights: SchedulingInsight[] = [];
    const metrics = this.calculateSchedulingMetrics(events);

    // Overdue events insight
    const now = new Date();
    const overdueEvents = events.filter(
      (e) => new Date(e.startTime) < now && e.status === "scheduled",
    );

    if (overdueEvents.length > 0) {
      insights.push({
        type: "pattern",
        title: `${overdueEvents.length} Overdue Events`,
        description: `You have ${overdueEvents.length} overdue events that need attention. Consider rescheduling or marking as completed.`,
        actionable: true,
        priority: "high",
        relatedData: {
          eventIds: overdueEvents.map((e) => e.id),
          timeRange: {
            start: Math.min(
              ...overdueEvents.map((e) => new Date(e.startTime).getTime()),
            ).toString(),
            end: now.toISOString(),
          },
        },
        suggestedAction: {
          title: "Review and Update",
          description:
            "Review overdue events and either reschedule or mark as completed",
          actionType: "reschedule",
        },
        createdAt: new Date().toISOString(),
      });
    }

    // Peak activity time insight
    if (events.length > 10) {
      const peakHour = metrics.mostActiveHour;
      const peakDay = metrics.mostActiveDay;
      const dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
      ];

      insights.push({
        type: "optimization",
        title: "Peak Activity Pattern",
        description: `Your busiest time is ${dayNames[peakDay]}s at ${peakHour}:00. Consider blocking this time for focused work.`,
        actionable: true,
        priority: "medium",
        relatedData: {
          timeRange: {
            start: new Date(
              Date.now() - 30 * 24 * 60 * 60 * 1000,
            ).toISOString(),
            end: new Date().toISOString(),
          },
        },
        suggestedAction: {
          title: "Optimize Schedule",
          description:
            "Block peak times for important activities or spread events more evenly",
          actionType: "optimize",
        },
        createdAt: new Date().toISOString(),
      });
    }

    // Follow-up completion rate insight
    if (metrics.followUpCompletionRate < 70) {
      insights.push({
        type: "suggestion",
        title: "Low Follow-up Completion Rate",
        description: `Only ${metrics.followUpCompletionRate.toFixed(1)}% of follow-ups are being completed. Consider setting reminders or simplifying follow-up tasks.`,
        actionable: true,
        priority: "medium",
        relatedData: {
          timeRange: {
            start: new Date(
              Date.now() - 30 * 24 * 60 * 60 * 1000,
            ).toISOString(),
            end: new Date().toISOString(),
          },
        },
        suggestedAction: {
          title: "Improve Follow-up Process",
          description:
            "Set up automated reminders and break down complex follow-ups into smaller tasks",
          actionType: "automate",
        },
        createdAt: new Date().toISOString(),
      });
    }

    return insights;
  }

  /**
   * Format event for calendar display
   */
  static formatEventForCalendar(event: CalendarEvent): {
    title: string;
    start: string;
    end: string;
    allDay: boolean;
    color: string;
    extendedProps: Record<string, unknown>;
  } {
    // Determine color based on event type and status
    let color = "#3b82f6"; // default blue

    switch (event.type) {
      case "follow-up":
        color = "#10b981"; // green
        break;
      case "appointment":
        color = "#8b5cf6"; // purple
        break;
      case "deadline":
        color = "#ef4444"; // red
        break;
      case "reminder":
        color = "#f59e0b"; // amber
        break;
    }

    if (event.status === "completed") {
      color = "#6b7280"; // gray
    } else if (event.status === "cancelled") {
      color = "#9ca3af"; // light gray
    }

    return {
      title: event.title,
      start: event.startTime,
      end: event.endTime,
      allDay: event.isAllDay,
      color,
      extendedProps: {
        eventId: event.id,
        clientId: event.clientId,
        conversationId: event.conversationId,
        type: event.type,
        status: event.status,
        description: event.description,
        metadata: event.metadata,
      },
    };
  }

  /**
   * Export events to standard calendar format (iCal)
   */
  static exportToICalendar(events: CalendarEvent[]): string {
    const lines = [
      "BEGIN:VCALENDAR",
      "VERSION:2.0",
      "PRODID:-//CRM System//Calendar Events//EN",
      "CALSCALE:GREGORIAN",
    ];

    events.forEach((event) => {
      lines.push(
        "BEGIN:VEVENT",
        `UID:${event.id}`,
        `DTSTART:${this.formatDateForICal(event.startTime)}`,
        `DTEND:${this.formatDateForICal(event.endTime)}`,
        `SUMMARY:${event.title}`,
        `DESCRIPTION:${event.description?.replace(/\n/g, "\\n") || ""}`,
        `STATUS:${event.status.toUpperCase()}`,
        `CREATED:${this.formatDateForICal(event.createdAt)}`,
        `LAST-MODIFIED:${this.formatDateForICal(event.updatedAt)}`,
        "END:VEVENT",
      );
    });

    lines.push("END:VCALENDAR");

    return lines.join("\r\n");
  }

  /**
   * Format date for iCal format
   */
  private static formatDateForICal(dateString: string): string {
    const date = new Date(dateString);
    return date
      .toISOString()
      .replace(/[-:]/g, "")
      .replace(/\.\d{3}/, "");
  }

  /**
   * Calculate optimal meeting times based on availability patterns
   */
  static suggestOptimalMeetingTimes(
    events: CalendarEvent[],
    duration: number = 60, // minutes
    daysAhead: number = 14,
  ): Array<{
    start: string;
    end: string;
    score: number;
    reason: string;
  }> {
    const suggestions: Array<{
      start: string;
      end: string;
      score: number;
      reason: string;
    }> = [];

    const now = new Date();
    const endDate = new Date(now.getTime() + daysAhead * 24 * 60 * 60 * 1000);

    // Business hours: 9 AM to 5 PM, Monday to Friday
    for (let day = now; day <= endDate; day.setDate(day.getDate() + 1)) {
      const dayOfWeek = day.getDay();

      // Skip weekends
      if (dayOfWeek === 0 || dayOfWeek === 6) continue;

      // Check each hour from 9 AM to 4 PM (to allow for 1-hour meetings)
      for (let hour = 9; hour <= 16; hour++) {
        const startTime = new Date(day);
        startTime.setHours(hour, 0, 0, 0);
        const endTime = new Date(startTime.getTime() + duration * 60 * 1000);

        // Skip past times
        if (startTime <= now) continue;

        // Check for conflicts
        const hasConflict = events.some((event) => {
          const eventStart = new Date(event.startTime);
          const eventEnd = new Date(event.endTime);
          return startTime < eventEnd && endTime > eventStart;
        });

        if (!hasConflict) {
          let score = 100;
          let reason = "Available time slot";

          // Prefer mid-morning and mid-afternoon
          if (hour === 10 || hour === 14) {
            score += 20;
            reason = "Optimal time for meetings";
          }

          // Prefer Tuesday to Thursday
          if (dayOfWeek >= 2 && dayOfWeek <= 4) {
            score += 15;
            reason += ", mid-week preferred";
          }

          // Avoid Monday morning and Friday afternoon
          if (
            (dayOfWeek === 1 && hour <= 10) ||
            (dayOfWeek === 5 && hour >= 15)
          ) {
            score -= 30;
            reason += ", but not ideal timing";
          }

          suggestions.push({
            start: startTime.toISOString(),
            end: endTime.toISOString(),
            score,
            reason,
          });
        }
      }
    }

    // Sort by score and return top suggestions
    return suggestions.sort((a, b) => b.score - a.score).slice(0, 10);
  }
}

export default CalendarUtils;
