// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Enhanced Participant model (extends the existing Participant interface)
model Participant {
  id        String   @id @default(cuid())
  name      String
  email     String?
  phone     String?
  company   String?
  role      ParticipantRole @default(CLIENT)
  
  // Contact preferences
  contactPreferences Json? // ContactPreferences object
  
  // Service profile
  services  Json? // ServiceType[] - stored as JSON array
  
  // External system IDs for integration
  bixbyContactId   String?
  googleContactId  String?
  
  // Relationships
  organizedAppointments Appointment[] @relation("OrganizerAppointments")
  participantAppointments AppointmentParticipant[]
  calendarIntegrations CalendarIntegration[]
  communications Communication[]
  clientRecord   ClientRecord?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([email])
  @@unique([phone])
  @@index([phone])
  @@index([email])
}

// Enhanced Appointment model with multi-participant support
model Appointment {
  id          String   @id @default(cuid())
  title       String
  description String?
  
  // Timing
  startTime   DateTime
  endTime     DateTime
  timezone    String   @default("America/Toronto")
  
  // Service details
  service     ServiceType
  location    String?
  
  // Status and management
  status      AppointmentStatus @default(SCHEDULED)
  
  // Organizer (main service provider)
  organizerId String
  organizer   Participant @relation("OrganizerAppointments", fields: [organizerId], references: [id])
  
  // Multiple participants
  participants AppointmentParticipant[]
  
  // External calendar integration
  googleCalendarEventId String?
  outlookCalendarEventId String?
  
  // Notifications
  notifications NotificationLog[]
  
  // Voice commands that created this appointment
  voiceCommands VoiceCommand[]
  
  // Voice command metadata
  voiceCommandData Json? // Store voice command context
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([startTime])
  @@index([service])
  @@index([status])
}

// Junction table for appointment participants
model AppointmentParticipant {
  id            String @id @default(cuid())
  appointmentId String
  participantId String
  
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  
  // Participant-specific details
  responseStatus ParticipantResponseStatus @default(NEEDS_ACTION)
  role          ParticipantAppointmentRole @default(ATTENDEE)
  notes         String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([appointmentId, participantId])
}

// Notification system
model NotificationLog {
  id            String @id @default(cuid())
  appointmentId String
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  
  type          NotificationType
  channel       NotificationChannel
  recipient     String // phone number or email
  
  status        NotificationStatus @default(PENDING)
  sentAt        DateTime?
  deliveredAt   DateTime?
  readAt        DateTime?
  
  content       String
  templateUsed  String?
  
  // Error handling
  errorMessage  String?
  retryCount    Int @default(0)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([appointmentId])
  @@index([type])
  @@index([status])
}

// Voice command integration
model VoiceCommand {
  id            String @id @default(cuid())
  
  // Voice processing
  transcript    String
  intent        VoiceIntent
  confidence    Float
  
  // Extracted entities
  participantName String?
  participantPhone String?
  service       ServiceType?
  requestedDateTime DateTime?
  
  // Processing results
  status        VoiceCommandStatus @default(PROCESSING)
  appointmentId String?
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  
  // Error handling
  errorMessage  String?
  
  // Metadata
  voiceProvider String? // 'retell_ai', 'synthflow', etc.
  sessionId     String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([intent])
  @@index([status])
}

// Enhanced Client Record (extends existing Client interface)
model ClientRecord {
  id            String @id @default(cuid())
  
  // Link to participant
  participantId String @unique
  participant   Participant @relation(fields: [participantId], references: [id])
  
  // Basic info (from existing Client interface)
  name          String
  email         String?
  phone         String?
  company       String?
  serviceId     String
  status        ClientStatus @default(ACTIVE)
  tags          Json? // String[] - stored as JSON array
  notes         String?
  
  // Service details
  projectType   String?
  serviceTypes  Json? // String[] - stored as JSON array
  budget        Float?
  timeline      String?
  seasonalContract Boolean @default(false)
  recurringService RecurringServiceType?
  
  // Location
  address       Json? // Address object
  
  // Service metadata
  metadata      Json? // Service-specific metadata
  
  // Contact preferences
  contactPreferences Json? // ContactPreferences object
  
  // CRM Integration data
  personalInfo     Json? // PersonalInfo object
  serviceProfile   Json? // ServiceProfile object
  billingInfo      Json? // BillingInfo object
  relationshipData Json? // RelationshipData object
  
  // Relationships
  serviceHistory   ServiceRecord[]
  serviceContracts ClientServiceContract[]
  billingRecords   BillingRecord[]
  communications   Communication[]
  documents        Document[]
  conversations    Conversation[]
  followUps        FollowUp[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([serviceId])
  @@index([status])
}

// Enhanced Service History
model ServiceRecord {
  id            String @id @default(cuid())
  clientId      String
  client        ClientRecord @relation(fields: [clientId], references: [id])
  
  // Service Line relationship
  serviceLineId String?
  serviceLine   ServiceLine? @relation(fields: [serviceLineId], references: [id])
  
  serviceDate   DateTime
  serviceType   ServiceType
  serviceArea   String?
  
  completionStatus CompletionStatus @default(SCHEDULED)
  notes         String?
  followUpNeeded Boolean @default(false)
  
  // Enhanced Billing
  amount        Float?
  currency      String @default("CAD")
  billingAmount Float? // individual service billing
  billingDate   DateTime? // when service was billed
  billingStatus BillingStatus @default(PENDING)
  
  // Relationships
  billingRecords BillingRecord[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([clientId])
  @@index([serviceLineId])
  @@index([serviceType])
  @@index([serviceDate])
  @@index([billingStatus])
}

// Service Line Model - Represents business divisions like "White Knight Snow Service" and "Woodgreen Landscaping"
model ServiceLine {
  id          String @id @default(cuid())
  name        String // e.g., "White Knight Snow Service", "Woodgreen Landscaping"
  slug        String @unique // e.g., "whiteknight", "woodgreen"
  description String?
  isActive    Boolean @default(true)
  color       String? // for UI differentiation
  
  // Relationships
  serviceContracts ClientServiceContract[]
  serviceRecords   ServiceRecord[]
  billingRecords   BillingRecord[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([slug])
  @@index([isActive])
}

// Enhanced Service Contract model for detailed service tracking
model ClientServiceContract {
  id            String @id @default(cuid())
  clientId      String
  client        ClientRecord @relation(fields: [clientId], references: [id])
  
  // Service Line relationship
  serviceLineId String?
  serviceLine   ServiceLine? @relation(fields: [serviceLineId], references: [id])
  
  // Service details (backward compatibility maintained)
  serviceId     String       // e.g., 'woodgreen', 'whiteknight'
  serviceName   String       // e.g., 'Woodgreen Landscaping', 'White Knight'
  serviceCategory String     // e.g., 'Lawn Maintenance', 'Snow Removal', 'Salting/De-Icing'
  
  // Status and timing
  status        ServiceContractStatus @default(ONGOING)
  period        String?      // e.g., 'Winter 2024-2025', 'Spring-Fall 2024', 'Ongoing'
  startDate     DateTime?
  endDate       DateTime?
  
  // Contract details
  contractValue Float?
  frequency     ServiceFrequency?
  notes         String?
  isActive      Boolean @default(true)
  isPrimary     Boolean @default(false) // indicates if this is the primary service
  
  // Enhanced contract details
  billingDetails Json? // flexible billing information storage
  seasonalInfo   Json? // seasonal contract details like "Winter 2024-2025"
  
  // Scheduling
  nextScheduled DateTime?    // next scheduled service date
  lastCompleted DateTime?    // last completed service date
  
  // Relationships
  billingRecords BillingRecord[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([clientId])
  @@index([serviceId])
  @@index([serviceLineId])
  @@index([status])
  @@index([isActive])
}

// Communication Log
model Communication {
  id            String @id @default(cuid())
  clientId      String
  client        ClientRecord @relation(fields: [clientId], references: [id])
  
  // Link to participant if available
  participantId String?
  participant   Participant? @relation(fields: [participantId], references: [id])
  
  timestamp     DateTime
  direction     CommunicationDirection
  channel       CommunicationChannel
  content       String
  
  purpose       CommunicationPurpose
  actionItems   Json? // String[] - stored as JSON array
  sentiment     SentimentLevel
  
  // Metadata
  subject       String?
  attachments   Json? // String[] - stored as JSON array
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([clientId])
  @@index([timestamp])
  @@index([purpose])
}

// Document management
model Document {
  id            String @id @default(cuid())
  clientId      String
  client        ClientRecord @relation(fields: [clientId], references: [id])
  
  name          String
  type          DocumentType
  status        DocumentStatus @default(DRAFT)
  
  fileUrl       String?
  content       String
  
  // Financial details
  amount        Float?
  currency      String @default("CAD")
  dueDate       DateTime?
  sentDate      DateTime?
  paidDate      DateTime?
  
  // Metadata
  metadata      Json?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([clientId])
  @@index([type])
  @@index([status])
}

// Conversation management
model Conversation {
  id            String @id @default(cuid())
  clientId      String
  client        ClientRecord @relation(fields: [clientId], references: [id])
  
  title         String?
  summary       String?
  nextActions   Json? // String[] - stored as JSON array
  
  sentiment     SentimentLevel?
  priority      PriorityLevel?
  tags          Json? // String[] - stored as JSON array
  status        ConversationStatus @default(ACTIVE)
  source        ConversationSource?
  
  participants  Json? // String[] - stored as JSON array
  relatedDocuments Json? // String[] - stored as JSON array
  
  // Messages
  messages      Message[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([clientId])
  @@index([status])
  @@index([priority])
}

// Message management
model Message {
  id            String @id @default(cuid())
  conversationId String
  conversation  Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  role          MessageRole
  content       String
  timestamp     DateTime
  type          MessageType
  
  // Metadata
  metadata      Json?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([conversationId])
  @@index([timestamp])
}

// Follow-up scheduling and management
model FollowUp {
  id            String @id @default(cuid())
  
  // Client relationship
  clientId      String
  client        ClientRecord @relation(fields: [clientId], references: [id], onDelete: Cascade)
  
  // Service relationship (optional - follow-up might be general)
  serviceId     String?
  
  // Scheduling details
  scheduledDate DateTime
  timezone      String @default("America/Toronto")
  duration      Int @default(60) // Duration in minutes
  
  // Recurrence pattern
  recurrencePattern RecurrencePattern @default(NONE)
  recurrenceData Json? // Store complex recurrence rules
  
  // Custom recurrence for flexible scheduling
  customInterval Int? // e.g., 2 for "every 2 weeks"
  customIntervalUnit String? // 'days', 'weeks', 'months'
  
  // Follow-up status and management
  status        FollowUpStatus @default(SCHEDULED)
  
  // Content and outcome
  title         String?
  notes         String?
  outcome       String?
  actionItems   Json? // String[] - stored as JSON array
  
  // Priority and categorization
  priority      PriorityLevel @default(MEDIUM)
  category      FollowUpCategory @default(GENERAL)
  
  // Notification tracking
  notificationsSent Json? // Track which reminders have been sent
  nextReminderAt DateTime?
  
  // External calendar integration
  googleCalendarEventId String?
  outlookCalendarEventId String?
  
  // Parent follow-up for recurring series
  parentFollowUpId String?
  parentFollowUp   FollowUp? @relation("FollowUpRecurrence", fields: [parentFollowUpId], references: [id])
  childFollowUps   FollowUp[] @relation("FollowUpRecurrence")
  
  // Related appointment if this follow-up was generated from an appointment
  sourceAppointmentId String?
  
  // Notifications
  notifications FollowUpNotification[] @relation("FollowUpNotifications")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([clientId])
  @@index([scheduledDate])
  @@index([status])
  @@index([category])
  @@index([nextReminderAt])
}

// Enhanced notification system for follow-ups
model FollowUpNotification {
  id            String @id @default(cuid())
  followUpId    String
  followUp      FollowUp @relation("FollowUpNotifications", fields: [followUpId], references: [id], onDelete: Cascade)
  
  type          FollowUpNotificationType
  channel       NotificationChannel
  recipient     String // phone number or email
  
  // Scheduling
  scheduledAt   DateTime
  sentAt        DateTime?
  deliveredAt   DateTime?
  readAt        DateTime?
  
  status        NotificationStatus @default(PENDING)
  
  content       String
  templateUsed  String?
  
  // Error handling
  errorMessage  String?
  retryCount    Int @default(0)
  maxRetries    Int @default(3)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([followUpId])
  @@index([scheduledAt])
  @@index([status])
}

// Business configuration for follow-up scheduling
model FollowUpConfiguration {
  id                    String @id @default(cuid())
  
  // Business hours configuration
  businessHoursStart    String @default("09:00") // HH:MM format
  businessHoursEnd      String @default("17:00") // HH:MM format
  workingDays          Json? // String[] - stored as JSON array
  timezone             String @default("America/Toronto")
  
  // Default reminder schedules
  defaultReminderDays  Json? // Int[] - stored as JSON array
  
  // Service-specific configurations
  serviceConfigurations Json? // ServiceType -> specific configuration
  
  // Notification preferences
  enableSMSReminders    Boolean @default(true)
  enableEmailReminders  Boolean @default(true)
  
  // Integration settings
  googleCalendarEnabled Boolean @default(false)
  outlookCalendarEnabled Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Calendar Integration
model CalendarIntegration {
  id            String @id @default(cuid())
  participantId String
  participant   Participant @relation(fields: [participantId], references: [id])
  
  provider      CalendarProvider
  externalId    String
  accessToken   String
  refreshToken  String?
  
  isActive      Boolean @default(true)
  lastSyncAt    DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([participantId, provider])
}

// Enums
enum ParticipantRole {
  CLIENT
  SERVICE_PROVIDER
  ADMIN
  TEAM_MEMBER
}

enum ServiceType {
  LAWN_CARE
  LANDSCAPING
  MAINTENANCE
  SNOW_REMOVAL
  EMERGENCY
  CONSULTATION
  DESIGN
  INSTALLATION
  // Woodgreen Landscaping specific service types
  TREE_TRIMMING
  LAWN_MOWING
  HEDGE_TRIMMING
  WEEDING
  GARDENING_PLANTING
  GARDENING_SEEDING
  MULCHING
  GUTTER_CLEANING
  DETHATCHING
  LEAF_REMOVAL
  // White Knight Snow Service specific service types
  PREMIUM_SALTING
  CALCIUM_MAGNESIUM_MIX
  SNOW_PLOWING
  ICE_MANAGEMENT
  WINTER_MAINTENANCE
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  RESCHEDULED
  NO_SHOW
}

enum ParticipantResponseStatus {
  NEEDS_ACTION
  ACCEPTED
  DECLINED
  TENTATIVE
}

enum ParticipantAppointmentRole {
  ORGANIZER
  ATTENDEE
  OPTIONAL
}

enum NotificationType {
  CONFIRMATION
  REMINDER_24H
  REMINDER_1H
  CANCELLATION
  RESCHEDULE
  FOLLOW_UP
}

enum NotificationChannel {
  SMS
  EMAIL
  VOICE_CALL
  PUSH_NOTIFICATION
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
}

enum VoiceIntent {
  BOOK_APPOINTMENT
  CHECK_CALENDAR
  CANCEL_APPOINTMENT
  RESCHEDULE_APPOINTMENT
  GET_AVAILABILITY
  UNKNOWN
}

enum VoiceCommandStatus {
  PROCESSING
  COMPLETED
  FAILED
  REQUIRES_CLARIFICATION
}

enum ClientStatus {
  ACTIVE
  INACTIVE
  PROSPECT
  COMPLETED
}

enum RecurringServiceType {
  ONE_TIME
  DAILY
  WEEKLY
  BI_WEEKLY
  MONTHLY
  SEASONAL
}

enum CompletionStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  PENDING
}

enum CommunicationDirection {
  INBOUND
  OUTBOUND
}

enum CommunicationChannel {
  SMS
  EMAIL
  PHONE
  IN_PERSON
  VIDEO_CALL
}

enum CommunicationPurpose {
  SCHEDULING
  SERVICE_UPDATE
  BILLING
  GENERAL
  COMPLAINT
  FOLLOWUP
  QUOTE_REQUEST
}

enum SentimentLevel {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

enum DocumentType {
  INVOICE
  QUOTE
  RECEIPT
  CONTRACT
  PROPOSAL
  ESTIMATE
  STATEMENT
  OTHER
}

enum DocumentStatus {
  DRAFT
  SENT
  VIEWED
  APPROVED
  PAID
  EXPIRED
  CANCELLED
}

enum PriorityLevel {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ConversationStatus {
  ACTIVE
  RESOLVED
  PENDING
  ARCHIVED
}

enum ConversationSource {
  EMAIL
  TEXT
  PHONE
  MEETING
  IMPORT
  MANUAL
}

enum MessageRole {
  CLIENT
  YOU
  AI_DRAFT
}

enum MessageType {
  EMAIL
  TEXT
  CALL_NOTES
  MEETING_NOTES
  VOICE_MEMO
  FILE_UPLOAD
}

enum CalendarProvider {
  GOOGLE
  OUTLOOK
  APPLE
  CALDAV
}

// Follow-up specific enums
enum RecurrencePattern {
  NONE
  DAILY
  WEEKLY
  BI_WEEKLY
  MONTHLY
  QUARTERLY
  SEMI_ANNUALLY
  ANNUALLY
  SEASONAL
  CUSTOM
}

// Service Contract specific enums
enum ServiceContractStatus {
  ONGOING
  COMPLETED
  PAUSED
  CANCELLED
  SCHEDULED
}

enum ServiceFrequency {
  ONE_TIME
  DAILY
  WEEKLY
  BI_WEEKLY
  MONTHLY
  SEASONAL
  AS_NEEDED
}

enum FollowUpStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  MISSED
  RESCHEDULED
}

enum FollowUpCategory {
  GENERAL
  SERVICE_CHECK
  PAYMENT_FOLLOW_UP
  MAINTENANCE_REMINDER
  SEASONAL_PLANNING
  PROJECT_UPDATE
  RELATIONSHIP_BUILDING
  COMPLAINT_RESOLUTION
  CONTRACT_RENEWAL
  UPSELL_OPPORTUNITY
}

enum FollowUpNotificationType {
  SCHEDULED
  REMINDER_7_DAYS
  REMINDER_24_HOURS
  REMINDER_1_HOUR
  COMPLETION_REQUEST
  MISSED_FOLLOW_UP
  RESCHEDULE_REQUEST
  OUTCOME_SUMMARY
}

// New Billing Status enum for service records and billing records
enum BillingStatus {
  PENDING
  BILLED
  PAID
  CANCELLED
  OVERDUE
}

// Billing Record Status enum
enum BillingRecordStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
  PARTIAL_PAYMENT
}

// Dedicated Billing Record model for comprehensive billing tracking
model BillingRecord {
  id            String @id @default(cuid())
  
  // Client relationship
  clientId      String
  client        ClientRecord @relation(fields: [clientId], references: [id])
  
  // Service Line relationship
  serviceLineId String
  serviceLine   ServiceLine @relation(fields: [serviceLineId], references: [id])
  
  // Service Record relationship (optional - for specific service billing)
  serviceRecordId String?
  serviceRecord   ServiceRecord? @relation(fields: [serviceRecordId], references: [id])
  
  // Contract relationship (optional)
  contractId    String?
  contract      ClientServiceContract? @relation(fields: [contractId], references: [id])
  
  // Billing details
  invoiceNumber String? @unique
  amount        Float
  currency      String @default("CAD")
  billingPeriod String // e.g., "Winter 2024-2025", "March 2025"
  billingDate   DateTime
  dueDate       DateTime?
  paidDate      DateTime?
  
  // Status and description
  status        BillingRecordStatus @default(DRAFT)
  description   String
  
  // Flexible metadata for billing details
  metadata      Json?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([clientId])
  @@index([serviceLineId])
  @@index([status])
  @@index([billingDate])
  @@index([invoiceNumber])
}
